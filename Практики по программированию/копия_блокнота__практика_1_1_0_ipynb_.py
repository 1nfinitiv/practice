# -*- coding: utf-8 -*-
"""Копия блокнота "Практика 1.1.0.ipynb"

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1D6Pjmal6A4_ozVsu80kysmPpQhonHEVe

**ФИО:**
"""



"""# Задание 1

**Описание:** Создайте иерархию классов для разных типов сотрудников в компании. Реализуйте родительский класс Employee и дочерние классы Manager и Developer. Каждый класс должен иметь метод для расчета зарплаты на основе различных критериев класса.


Отрабатываемый принцип: Наследование
"""

class Employee:
    def __init__(self, name, base_salary):
        self.name = name
        self.base_salary = base_salary

    def calculate_salary(self):
        return self.base_salary

    def __str__(self):
        return f"Employee: {self.name}, Salary: {self.calculate_salary()}"

class Manager(Employee):
    def __init__(self, name, base_salary, bonus):
        super().__init__(name, base_salary)
        self.bonus = bonus

    def calculate_salary(self):
        return self.base_salary + self.bonus

    def __str__(self):
        return f"Manager: {self.name}, Salary: {self.calculate_salary()}"

class Developer(Employee):
    def __init__(self, name, base_salary, projects_completed):
        super().__init__(name, base_salary)
        self.projects_completed = projects_completed

    def calculate_salary(self):
        # Допустим, за каждый завершенный проект разработчик получает 1000
        return self.base_salary + (self.projects_completed * 1000)

    def __str__(self):
        return f"Developer: {self.name}, Salary: {self.calculate_salary()}"

if __name__ == "__main__":
    manager = Manager("Misha", 5000, 2000)
    developer = Developer("Vlad", 4000, 3)

    print(manager)
    print(developer)

"""# Задание 2

**Описание:** Создайте иерархию классов для различных типов транспортных средств (Необходим один родительский класс и 3 дочерних). Реализуйте метод, который позволяет каждому транспортному средству возвращать собственное описание (Метод в каждом классе должен иметь одинаковое название). Продемонстрируйте вызов данного метода для каждого транспортного средства.


Отрабатываемый принцип: Полиморфизм
"""

class Vehicle:
    def description(self):
        return "Это транспортное средство"

class Car(Vehicle):
    def __init__(self, make, model):
        self.make = make
        self.model = model

    def description(self):
        return f"Это машина. Марка: {self.make}, Модель: {self.model}"

class Scooter(Vehicle):
    def __init__(self, make, type_of_scooter):
        self.make = make
        self.type_of_scooter = type_of_scooter

    def description(self):
        return f"Это самокат. Марка: {self.make}, Модель: {self.type_of_scooter}"

class Plane(Vehicle):
    def __init__(self, make, capacity):
        self.make = make
        self.capacity = capacity

    def description(self):
        return f"Это самолет. Марка: {self.make}, Вместимость: {self.capacity} человек"

if __name__ == "__main__":
    vehicles = [
        Car("Toyota", "Camry"),
        Scooter("Kugoo", "Kirin M4 PRO"),
        Plane("Airbus", 180)
    ]

    for vehicle in vehicles:
        print(vehicle.description())

"""# Задание 3

Онлайн-магазин:
- Создайте модель для онлайн-магазина с классами Product, Order, Customer, и ShoppingCart.
- Product включает информацию о цене, наличии на складе и категории товара.
Order обрабатывает процесс покупки, включая расчет цены с учетом скидок и налогов.
- Customer управляет информацией о пользователе и его истории заказов.
- ShoppingCart позволяет добавлять, удалять и обновлять количество товаров перед оформлением заказа.
"""

class Product:
    def __init__(self, name, price, stock, category):
        self.name = name
        self.price = price
        self.stock = stock
        self.category = category

    def is_available(self, quantity):
        return self.stock >= quantity

    def reduce_stock(self, quantity):
        if self.is_available(quantity):
            self.stock -= quantity
        else:
            raise ValueError("Недостаточно товара на складе.")


class Order:
    def __init__(self, customer):
        self.customer = customer
        self.items = []
        self.total_price = 0.0

    def add_item(self, product, quantity):
        if product.is_available(quantity):
            product.reduce_stock(quantity)
            self.items.append((product, quantity))
            self.calculate_total()
        else:
            raise ValueError("Недостаточно товара на складе.")

    def calculate_total(self, discount=0.0, tax_rate=0.0):
        subtotal = sum(product.price * quantity for product, quantity in self.items)
        discount_amount = subtotal * (discount / 100)
        tax_amount = (subtotal - discount_amount) * (tax_rate / 100)
        self.total_price = subtotal - discount_amount + tax_amount


class Customer:
    def __init__(self, name, email):
        self.name = name
        self.email = email
        self.orders = []

    def place_order(self, order):
        self.orders.append(order)


class ShoppingCart:
    def __init__(self):
        self.items = {}

    def add_product(self, product, quantity):
        if product.is_available(quantity):
            if product in self.items:
                self.items[product] += quantity
            else:
                self.items[product] = quantity
        else:
            raise ValueError("Недостаточно товара на складе.")

    def remove_product(self, product):
        if product in self.items:
            del self.items[product]
        else:
            raise ValueError("Товар не найден в корзине.")

    def update_quantity(self, product, quantity):
        if product in self.items:
            if quantity <= 0:
                self.remove_product(product)
            else:
                if product.is_available(quantity):
                    self.items[product] = quantity
                else:
                    raise ValueError("Недостаточно товара на складе.")
        else:
            raise ValueError("Товар не найден в корзине.")

    def clear_cart(self):
        self.items.clear()

    def get_total(self):
        return sum(product.price * quantity for product, quantity in self.items.items())


if __name__ == "__main__":
    # Создаем продукты
    product1 = Product("Смартфон", 500.00, 10, "Электроника")
    product2 = Product("Ноутбук", 1000.00, 5, "Электроника")

    # Создаем клиента
    customer = Customer("Иван Иванов", "ivan@example.com")

    # Создаем корзину покупок
    cart = ShoppingCart()
    cart.add_product(product1, 2)
    cart.add_product(product2, 1)

    # Создаем заказ
    order = Order(customer)

    for product, quantity in cart.items.items():
        order.add_item(product, quantity)

    # Рассчитываем общую стоимость с учетом скидки и налога
    order.calculate_total(discount=10.0, tax_rate=5.0)

    # Клиент оформляет заказ
    customer.place_order(order)

    print(f"Общая стоимость заказа: {order.total_price:.2f} руб.")

"""# Задание 4

Симулятор космического корабля:
- Создайте симулятор управления космическим кораблем с классами SpaceShip, CrewMember, и Mission.
- SpaceShip имеет атрибуты для управления топливом, состоянием корпуса, и текущей скоростью.
- CrewMember контролирует здоровье, навыки, и роли в команде (например, пилот, инженер).
- Mission определяет цели, ресурсы, и возможные события (например, аварии, встречи с астероидами).
"""

import random


class SpaceShip:
    def __init__(self, fuel, hull_integrity, speed):
        self.fuel = fuel  # Топливо
        self.hull_integrity = hull_integrity  # Состояние корпуса (0-100)
        self.speed = speed  # Текущая скорость

    def fly(self, distance):
        fuel_needed = distance * 0.1  # Расход топлива на 1 км
        if fuel_needed > self.fuel:
            print("Недостаточно топлива для полета.")
            return False
        else:
            self.fuel -= fuel_needed
            print(f"Корабль полетел на {distance} км.")
            return True

    def repair(self, amount):
        if amount <= 0:
            print("Количество ремонта должно быть положительным.")
            return
        self.hull_integrity = min(100, self.hull_integrity + amount)
        print(f"Корпус отремонтирован до {self.hull_integrity}.")


class CrewMember:
    def __init__(self, name, health, skills, role):
        self.name = name  # Имя члена экипажа
        self.health = health  # Здоровье (0-100)
        self.skills = skills  # Навыки (например, "пилот", "инженер")
        self.role = role  # Роль в команде

    def perform_task(self, task):
        if task in self.skills:
            success = random.choice([True, False])
            if success:
                print(f"{self.name} успешно выполнил задачу: {task}.")
            else:
                print(f"{self.name} не смог выполнить задачу: {task}.")
        else:
            print(f"{self.name} не имеет необходимых навыков для выполнения задачи: {task}.")


class Mission:
    def __init__(self, objectives, resources):
        self.objectives = objectives  # Цели миссии
        self.resources = resources  # Ресурсы для выполнения миссии

    def encounter_event(self):
        events = ["астероид", "космический мусор", "встреча с инопланетянами"]
        event = random.choice(events)
        print(f"Миссия столкнулась с событием: {event}.")

        if event == "астероид":
            damage = random.randint(5, 20)
            print(f"Корабль получил повреждение корпуса на {damage}.")
            return damage
        elif event == "космический мусор":
            print("Корабль успешно избежал столкновения с космическим мусором.")
            return 0
        elif event == "встреча с инопланетянами":
            print("Корабль установил контакт с инопланетянами.")
            return 0


if __name__ == "__main__":
    spaceship = SpaceShip(fuel=100, hull_integrity=100, speed=50)
    crew_member1 = CrewMember(name="Алекс", health=100, skills=["пилот", "инженер"], role="пилот")
    crew_member2 = CrewMember(name="Мария", health=100, skills=["инженер"], role="инженер")

    mission = Mission(objectives=["достичь планеты X", "собрать образцы"], resources={"топливо": 50})

    # Выполнение задач и событий
    crew_member1.perform_task("пилот")
    crew_member2.perform_task("ремонт")

    spaceship.fly(200)
    damage = mission.encounter_event()
    if damage > 0:
        spaceship.repair(-damage)  # Уменьшаем здоровья коробля при повреждении

"""# Дополнительно:

**Описание:** создайте консольную версию игры крестики-нолики, используя классы
"""

